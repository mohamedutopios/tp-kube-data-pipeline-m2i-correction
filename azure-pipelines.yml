trigger:
  branches:
    include:
      - main
  paths:
    include:
      - producer/*
      - spark-app/*
      - web/*
      - k8s/*

variables:
  ACR_NAME: "myacr.azurecr.io"
  IMAGE_TAG: "$(Build.BuildId)"
  K8S_NAMESPACE: "default"

stages:
# ==========================================================
#                       CI – Detection + Build
# ==========================================================
- stage: CI
  displayName: "Build + Scan + Push images"
  jobs:

  - job: detect_changes
    displayName: "Détecter les microservices modifiés"
    outputs:
      spark_changed: detect.changed_spark
      prod_changed: detect.changed_producer
      web_changed: detect.changed_web
    steps:
      - checkout: self
        persistCredentials: true

      # Vérifier si chaque service a changé
      - bash: |
          echo "## Détection des changements"

          git diff --quiet HEAD~1 HEAD -- producer || echo "##vso[task.setvariable variable=changed_producer]true"
          git diff --quiet HEAD~1 HEAD -- spark-app || echo "##vso[task.setvariable variable=changed_spark]true"
          git diff --quiet HEAD~1 HEAD -- web || echo "##vso[task.setvariable variable=changed_web]true"

          # Valeur par défaut false pour éviter NULL
          echo "Producer: $(changed_producer)"
          echo "Spark:    $(changed_spark)"
          echo "Web:      $(changed_web)"

        name: detect
        displayName: "Analyse des dossiers modifiés"

  # --------------------------------------------------------------------
  # BUILD PRODUCER
  # --------------------------------------------------------------------
  - job: build_producer
    displayName: "Build Producer image"
    dependsOn: detect_changes
    condition: eq(dependencies.detect_changes.outputs['detect.changed_producer'], 'true')

    steps:
      - checkout: self

      - bash: |
          docker build -t $(ACR_NAME)/producer:$(IMAGE_TAG) ./producer
      displayName: "Docker build producer"

      - bash: |
          trivy image --exit-code 1 --severity CRITICAL $(ACR_NAME)/producer:$(IMAGE_TAG)
      displayName: "Scan Trivy Producer"

      - bash: |
          az acr login --name $(ACR_NAME)
          docker push $(ACR_NAME)/producer:$(IMAGE_TAG)
      displayName: "Push image Producer"

      # Mise à jour du manifest
      - bash: |
          sed -i "s|image: .*/producer:.*|image: $(ACR_NAME)/producer:$(IMAGE_TAG)|" k8s/apps-producer.yaml
      displayName: "Maj manifest producer"

      # Publier manifest mis à jour pour CD
      - publish: k8s/apps-producer.yaml
        artifact: producer-manifest

  # --------------------------------------------------------------------
  # BUILD SPARK
  # --------------------------------------------------------------------
  - job: build_spark
    displayName: "Build Spark image"
    dependsOn: detect_changes
    condition: eq(dependencies.detect_changes.outputs['detect.changed_spark'], 'true')

    steps:
      - checkout: self

      - bash: |
          docker build -t $(ACR_NAME)/spark-app:$(IMAGE_TAG) ./spark-app
      displayName: "Docker build spark"

      - bash: |
          trivy image --exit-code 1 --severity CRITICAL $(ACR_NAME)/spark-app:$(IMAGE_TAG)
      displayName: "Scan Spark image"

      - bash: |
          az acr login --name $(ACR_NAME)
          docker push $(ACR_NAME)/spark-app:$(IMAGE_TAG)
      displayName: "Push image Spark"

      - bash: |
          sed -i "s|image: .*/spark-app:.*|image: $(ACR_NAME)/spark-app:$(IMAGE_TAG)|" k8s/apps-spark.yaml
      displayName: "Maj manifest spark"

      - publish: k8s/apps-spark.yaml
        artifact: spark-manifest

  # --------------------------------------------------------------------
  # BUILD WEB
  # --------------------------------------------------------------------
  - job: build_web
    displayName: "Build Web image"
    dependsOn: detect_changes
    condition: eq(dependencies.detect_changes.outputs['detect.changed_web'], 'true')

    steps:
      - checkout: self

      - bash: |
          docker build -t $(ACR_NAME)/web:$(IMAGE_TAG) ./web
      displayName: "Docker build web"

      - bash: |
          trivy image --exit-code 1 --severity CRITICAL $(ACR_NAME)/web:$(IMAGE_TAG)
      displayName: "Scan Web image"

      - bash: |
          az acr login --name $(ACR_NAME)
          docker push $(ACR_NAME)/web:$(IMAGE_TAG)
      displayName: "Push image Web"

      - bash: |
          sed -i "s|image: .*/web:.*|image: $(ACR_NAME)/web:$(IMAGE_TAG)|" k8s/apps-web.yaml
      displayName: "Maj manifest web"

      - publish: k8s/apps-web.yaml
        artifact: web-manifest


# ==========================================================
#                        CD – Déploiement AKS
# ==========================================================
- stage: CD
  displayName: "Déploiement AKS"
  dependsOn: CI

  jobs:
    - deployment: deploy_k8s
      displayName: "Apply manifests mis à jour"
      environment: "aks-env"
      strategy:
        runOnce:
          deploy:
            steps:

              # Auth AKS
              - task: AzureCLI@2
                displayName: "Connexion AKS"
                inputs:
                  azureSubscription: "aks-connection"
                  scriptType: bash
                  scriptLocation: inlineScript
                  inlineScript: |
                    az aks get-credentials \
                      --resource-group myRG \
                      --name myAKS \
                      --overwrite-existing

              # Déploiement seulement des manifests mis à jour
              - download: current
                artifact: producer-manifest
                condition: exists('$(Pipeline.Workspace)/producer-manifest/apps-producer.yaml')

              - download: current
                artifact: spark-manifest
                condition: exists('$(Pipeline.Workspace)/spark-manifest/apps-spark.yaml')

              - download: current
                artifact: web-manifest
                condition: exists('$(Pipeline.Workspace)/web-manifest/apps-web.yaml')

              - bash: |
                  echo "Déploiement Kubernetes…"
                  for f in $(Pipeline.Workspace)/**/*.yaml; do
                    echo "Applying $f"
                    kubectl apply -f $f -n $(K8S_NAMESPACE)
                  done
              displayName: "Kubectl apply"

              # Forcer un rollout intelligent (restart safe)
              - bash: |
                  kubectl rollout restart deployment/producer -n $(K8S_NAMESPACE) || true
                  kubectl rollout restart deployment/spark-app -n $(K8S_NAMESPACE) || true
                  kubectl rollout restart deployment/web -n $(K8S_NAMESPACE) || true
              displayName: "Rollout Restart"
